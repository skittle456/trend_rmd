ขั้นตอนวิธีของทาร์จัน  คือขั้นตอนวิธีสำหรับการหา strongly connected components แต่ละ component บน directed graph ซึ่งถูกคิดค้นโดย โรเบิร์ด ทาร์จันconnected graph คือ กราฟที่มีวิถีระหว่าง vertex ใดๆไปยังทุกๆ vertex ภายในกราฟstrongly connected graph คือ directed graph ที่มีวิถีระหว่าง vertex ใดๆไปยังทุกๆ vertex ภายในกราฟstrongly connected component คือ strongly connected graph ที่เป็นกราฟย่อยของกราฟใหญ่แนวคิดของขั้นตอนวิธีของทาร์จันจะเริ่มจาก vertex เริ่มต้น ซึ่งเป็น vertex เริ่มต้น ซึ่งสามารถเป็น vertex ใดๆก็ได้ภายในกราฟ จากนั้นจะเข้าถึง  แต่ละ vertex โดยใช้วิธีการ Depth-first search  เข้าสู่ adjacent vertex ต่อไป โดยจะไม่มีการ traverse vertex ซ้ำ, ตัวอย่างเช่น หาก vertex v1 ถูก traverse ไปแล้ว จะไม่มีการ traverse v1 ซ้ำอีกครั้ง , โดยการหา strongly connected components จะหาจากการระบุ vertex แรกที่พบจากการ Depth-first search ของแต่ละ strongly connected component โดยจะเรียก vertex ดังกล่าวว่า "root"  แต่ละต้นภายในกราฟ ดังนั้น vertex แรกที่อยู่ใน strongly connected component ที่พบจากการ Depth-first search จึงเป็น vertex ที่บอกว่า vertex ต่อไปอยู่ใน strongly connected component ด้วย จึงเรียก vertex ดังกล่าวว่า "root") แต่ปัญหาของ Tarjan's algorithm คือจะรู้ได้อย่างไรว่า vertex ใดเป็น root ของแต่ละ strongly connected component บ้าง จึงมีการใช้กองซ้อน  และปม  ในการช่วยแก้ไขปัญหาดังกล่าวการสร้างปม ซึ่งแต่ละปม จะแทนแต่ละ vertex โดยภายในปม จะเก็บข้อมูล 2 ตัว คือ index : เก็บหมายเลข vertex ซึ่งเป็นหมายเลขตัวแทน vertex แต่ละ vertex lowlink : เก็บหมายเลข vertex  ของ vertex ที่เป็น root ของ vertex นี้การใช้ stack จะมีการแบ่ง vertex ทั้งหมดของกราฟ ออกเป็น 2 ส่วน คือ1. vertex ที่อยู่ใน stack : stack จะเก็บ vertex ต่างๆที่กำลังถูก traverse  ในขณะนี้2. vertex ที่อยู่นอก stack : เป็น vertex ที่ถูก traverse เสร็จเรียบร้อยแล้ว หรือยังไม่ถูก traverse เลยการทำงานขั้นตอนวิธีของทาร์จัน จะใช้วิธี Depth-first search แต่ละ vertex ไปยัง adjacent vertices ที่ยังไม่ถูก traverse ในรูปแบบของการ recursive โดยมีเงื่อนไขว่า 1. หากพบว่า adjacent vertex คือ vertex ที่ยังไม่ถูก traverse : ให้ traverse adjacent vertex นั้นก่อน จากนั้น set ค่า lowlink ของ vertex ปัจจุบันเป็นค่าที่น้อยกว่าระหว่างค่า lowlink ของ v กับค่า lowlink ของ v'2. หากพบว่า adjacent vertex คือ vertex ที่กำลังถูก traverse หรืออยู่ภายใน stack : จะแสดงว่ามี cycle ภายในกราฟ ซึ่งทำให้เกิด strongly connected component , ให้ vertex ปัจจุบันมีค่า lowlink ของ vertex ปัจจุบันเป็นค่าที่น้อยกว่าระหว่างค่า lowlink ของ v กับค่า index ของ v'เมื่อเสร็จสิ้นการทำงานดังกล่าวจะพบว่า หากมี strongly connected component ค่า lowlink จะมีค่าเป็นหมายเลขของ root vertex ของ strongly connected component นั้น ดังนั้นหาก vertex ใดมีค่า lowlink จะมีค่าเท่ากับหมายเลขของ vertex นั้น แสดงว่า vertex นั้นเป็น root ของ strongly connected component นั้น จึงทำการ pop vertex ใน stack ออกมาเพื่อแสดงผล  ว่ามี vertex ใดภายใน strongly connected component นี้บ้าง ซึ่งจะ pop ค่าออกมาจนกระทั่งพบ vertex ตนเอง จึงหยุด pop ค่าออกจาก stack• การอธิบายแนวคิดนี้ จะใช้สัญลักษณ์สีเพื่อประกอบความเข้าใจ ได้แก่vertex สีขาว : แทน vertex ที่ยังไม่ถูก traversevertex สีเทา : แทน vertex ที่ยังกำลังถูก traverse ในขณะนี้ vertex สีดำ : แทน vertex ที่ยังถูก traverse เสร็จเรียบร้อยแล้ว1.มีกราฟ G ที่มีทั้งหมด 7 vertices 2.เริ่มทำการ Depth-first search จาก v0 โดยเริ่มต้น index และ lowlonk ของแต่ละ vertex จะมีค่าเท่ากับหมายเลข vertex ของตนเอง ซึ่ง v0 จะมีค่า index และ lowlink เท่ากับ 0 จะเห็นว่าขณะนี้มีการ traverse v0 จึงให้ v0 เป็นสีเทา 3.ทำการ Depth-first search ไปยัง adjacent vertex ของ v0 นั่นคือ v1 และ v3 ตามลำดับ เริ่มจาก traverse v1 และ set ค่า ให้กับ index และ lowlink ให้เท่ากับหมายเลข vertex ของตนเอง4.จากนั้น Depth-first search ไปยัง adjacent vertex ของ v1 นั่นคือ v2 เริ่มจาก traverse v2 และ set ค่า ให้กับ index และ lowlink ให้เท่ากับหมายเลข vertex ของตนเอง5.จากนั้น Depth-first search ไปยัง adjacent vertex ของ v2 นั่นคือ v1 ซึ่งเป็น vertex ที่กำลังถูก traverse จึงเปรียบเทียบค่าน้อยกว่าระหว่างค่า lowlink ของ v2 กับค่า index ของ v1 ให้เป็นค่า lowlink ของ v26.v2 ไม่มี adjacent vertex อื่น จึงตรวจสอบว่า index กับ lowlink ของ v2 มีค่าเท่ากันหรือไม่ แน่นอนว่าไม่เท่ากัน การ Depth-first search จึงกลับไปที่ v1 และตรวจสอบในทำนองเดียวกัน พบว่า index กับ lowlink ของ v1 มีค่าเท่ากัน จึง pop vertex บนสุดออกมาจาก stack คือ v2  นำ v2 แสดงออกบนหน้าจอ 7.pop vertex ออกจาก stack จนกระทั่งพบว่า vertex ที่ pop ออกมาคือ vertex ปัจจุบัน  จากนั้นหยุดการ pop 8.กลับมาพิจารณาการ Depth-first search adjacent vertex ถัดไปของ v0 คือ v39.ในทำนองเดียวกับ v0 , v3 จะทำการ Depth-first search ตามแต่ละ adjacent vertex คือ v4 และ v5 ตามลำดับ10.v4 จะทำการ Depth-first search ตามแต่ละ adjacent vertex คือ v5 และ v6 ตามลำดับ11.v5 จะทำการ Depth-first search ไปยัง v0 ซึ่งเป็น vertex ที่กำลังถูก traverse หรืออยู่ใน stack ขณะนี้ จึงทำการเปรียบเทียบค่าน้อยกว่าระหว่างค่า lowlink ของ v5 กับค่า index ของ v0 ให้เป็นค่า lowlink ของ v512.v5 ไม่มี adjacent vertex อื่น จึงกลับมาพิจารณา v4 และกำหนดค่า lowlink ของ v4 เป็นค่าที่น้อยกว่าระหว่างค่า lowlink ของ v4 กับค่า lowlink ของ v513.จากนั้น Depth-first search adjacent vertex ของ v4 ถัดไปคือ v614.v6 ไม่มี adjacent vertex ใดเลย และพบว่า index กับ lowlink ของ v6 มีค่าเท่ากัน จึง pop vertex บนสุดออกมาจาก stack และพบว่า vertex นั้นคือ v6 จึงแสดงผล strongly connected component ที่มีเพียง v6 เท่านั้นภายใน component นี้ 15.กลับมาพิจารณาที่ v4 พบว่าไม่พบ adjacent vertex อื่น จึงกลับไปพิจารณาที่ v3 โดย v3 จะเปรียบเทียบนำค่าที่น้อยกว่าระหว่างค่า lowlink ของ v3 กับค่า lowlink ของ v4 และนำมาใส่ในค่า lowlink ของ v316.v3 ที่มี adjacent vertex อื่นอีกคือ v5 แต่ v5 ที่ถูก traverse ไปแล้วจึงไม่ traverse v5 อีกครั้ง และกลับไปพิจารณาที่ v0  ซึ่งพบว่า index กับ lowlink ของ v0 มีค่าเท่ากัน จึง pop vertex ออกจาก stack จนกว่าจะเจอ vertex ตนเอง พร้อม print ค่า vertex ต่างๆออกมาแสดงเป็น strongly connected component อีกส่วนหนึ่ง 